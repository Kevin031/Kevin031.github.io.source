---
title: 实战总结：H5高帧率拼手速游戏的难点分析和优化思路
date: 2020-04-02 19:35:00
categories:
  - 前端
tags:
  - Javascript
  - CSS
  - 浏览器
---

![](http://data.kevinlau.cn/sites/default/files/post-image/ezgif-3-238f304a6d0a.gif)

这是我大四实习接触的一个项目，玩法非常简单，屏幕中央有一个魔方，上方有一个秒表，点击屏幕的任意位置，魔方就会朝复原的状态拧一下，复原成功后会告诉用户用了多长时间，然后是一些抽奖，类似于支付宝集五福。

Ps: 这个项目的目的之一可能是告诉你世界纪录有多快，6秒，你无脑点屏幕的速度可能还没他快......

这一简单的项目大致看了一遍会发现很多难点，比如魔方的绘制真的是需要「建模」的，转动过程需要和公式绑定，而秒表精确到了小数点后2位，渲染秒表读数的操作想想就知道肯定会和魔方的转动动画互相卡。

确实在开发的过程中，我遇到了以下难点：

1. 魔方的「建模」与公式绑定
2. 秒表读数随着魔方动画发生了卡顿
3. 游戏的难度设置

### 核心逻辑

每个看似复杂的项目都有核心逻辑在里面，我认为的核心逻辑即用户快速点击屏幕，到了一定的次数任务完成，记录时间。那么其余的都只是系统随着用户操作和时间流逝发生的一些被动反馈罢了。

总结出这一逻辑，选型上直接用了``Vue``，因为涉及到了一些繁琐的状态管理，屏幕管理，以及一系列高频的``DOM``操作，``Vue``可以很好地让我将思维集中在操作数据模型上。

### 知识点准备

页面的Renderer进程包含了哪些线程

可以这样理解，页面的渲染，JS的执行，事件的循环，都在一个进程内进行，并且是多线程的，其中有以下常见线程：

1. **GUI渲染线程，最多一个，用于3D绘制**<br>
负责渲染浏览器界面，解析``HTML``，``CSS``，构建``DOM``树和渲染树，布局和绘制等。
当界面需要重绘或者某种操作引发回流时，该线程就会执行。
GUI渲染线程与JS引擎线程互斥，当JS引擎执行时GUI线程会被挂起（相当于冻结），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。

2. **JS引擎线程**<br>
也称为JS内核，负责解析``Javascript``脚本并运行代码（如V8）。
JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个页面进程中无论如何都只有一个JS线程在运行JS程序。
如果JS执行的时间过长，就会造成GUI渲染线程不连贯，导致页面阻塞。

3. **事件触发线程**<br>
归属于浏览器而不是JS引擎，用来控制事件循环。
当JS引擎执行代码块如``setTimeout``时，会将对应任务添加到事件线程中。
当对应的事件符合触发条件时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。
由于JS是单线程的，所以这些待处理队列中的事件都会排队等待JS引擎处理（当JS引擎空闲时才会执行）

4. **定时触发器线程**<br>
``setInterval``和``setTimeout``所在线程。
浏览器定时计数器并不是JS引擎计数的，由于JS单线程的原因，运行阻塞会影响计时的准确性。
计时完毕后，会添加事件队列，等待JS引擎空闲后执行。
W3C的HTML标准规定``setTimeout``中低于4ms的时间按4ms处理

5. **异步http请求线程**<br>
在``XMLHttpRequest``连接后，新开一个线程来进行请求。
当检测到请求状态变更时，如果设置了回调函数，会产生状态变更事件，将这个回调放入事件队列中，再由JS引擎在空闲时执行。

PS: 如何将普通图层变成复合图层

1. ``translate3d``、``translateZ``的元素
2. ``transition``，``animation``，但是只会在动画执行过程中会创建复合图层
3. ``will-change``属性，一般配合``opacity``和translate使用（提前告诉浏览器要变化，浏览器会做些优化工作）
4. ``<video>````<iframe>````<canvas>````<webgl>``等元素
5. ``flash``插件

### 难点1 魔方的建模

因为我本来就不熟悉魔方的玩法和复原公式的规律，但是有人是能做到并且用程序实现，幸运的是codepen上就有大牛们实现的一些demo，这省去了我从头开始构思的时间，以及总结时估计能洋洋洒洒写出的一万字。

这里我特地找了通过CSS3来实现动画的demo，原因是GUI渲染线程与JS引擎线程互斥，因此这一块可以交给CSS的``transform``/``translate``即GPU进程去做，浏览器中每个tab页面是一个进程，而GPU则独立一个进程，因此上文的页面进程中没有提到它。

浏览器包含了普通图层和复合图层，``GPU``进程用的就是传说中硬件加速技术，直接把``translate``的元素脱离文档流变成复合图层，并且各个复合图层都是单独绘制的，互不影响。

### 难点2 秒表读读数的卡顿

客户对这一点要求会比较高，首先秒表一定要精确到小数点后两位，其次要求读数变化真实流畅，这一概念其实就是画面中小数点最后一位由0-9不停变化，其实。

提到秒表的实现逻辑，首先想到的是``setTimeout``和``setInterval``。

首先在这里``setTimeout``的递归肯定是不能用的，因为转换时间的逻辑和``DOM``操作需要一定的时间，这会阻塞``setTimeout``这行代码的执行，导致最后算出来的时间是不准的。

``setInterval``相对来说会准确一些，因为它是由触发器线程来管理的，因此添加事件队列的时间会比较准确，然而即使进了事件队列，也需要等到JS引擎空闲时才会执行，出现的情况就是几个``setInterval``的回调函数由于都被阻塞了，所以执行的时间非常接近，视觉上的直观感受就是秒表的读数变化虽然准确，但是忽快忽慢。

我还尝试了一些别的方法，``requestAnimationFrame``也是一个思路，每一次回调会读取当前的系统时间反馈给用户，读数变化会稍微流畅一点。

做了许多的努力，最后用了一个骚操作，就是通过``CSS``来渲染秒表动画，用户复原魔方后，返回耗时，那么JS就只需要计算一遍时间，剩下的都交给``GPU``进程去处理。

核心代码:
```
// 动画函数，内容往上翻
@keyframes unit {
  0% {
    transform: translateY(0);
  }
  100% {
    transform: translateY(-60em);
  }
}

// 秒的部分
.unit-second:after {
  content: "00\A 01\A 02\A 03\A 04\A 05\A 06\A 07\A 08\A 09\A 10\A 11\A 12\A 13\A 14\A 15\A 16\A 17\A 18\A 19\A 20\A 21\A 22\A 23\A 24\A 25\A 26\A 27\A 28\A 29\A 30\A 31\A 32\A 33\A 34\A 35\A 36\A 37\A 38\A 39\A 40\A 41\A 42\A 43\A 44\A 45\A 46\A 47\A 48\A 49\A 50\A 51\A 52\A 53\A 54\A 55\A 56\A 57\A 58\A 59\A 60\A 61\A 62\A 63\A 64\A 65\A 66\A 67\A 68\A 69\A 70\A 71\A 72\A 73\A 74\A 75\A 76\A 77\A 78\A 79\A 80\A 81\A 82\A 83\A 84\A 85\A 86\A 87\A 88\A 89\A 90\A 91\A 92\A 93\A 94\A 95\A 96\A 97\A 98\A 99\A";
  animation: centiseconds steps(100) infinite;
  animation-duration: 1s;
  display: inline-block;
}

// 毫秒的部分
.unit-sentiseconds:after {
  content: "00\A 01\A 02\A 03\A 04\A 05\A 06\A 07\A 08\A 09\A 10\A 11\A 12\A 13\A 14\A 15\A 16\A 17\A 18\A 19\A 20\A 21\A 22\A 23\A 24\A 25\A 26\A 27\A 28\A 29\A 30\A 31\A 32\A 33\A 34\A 35\A 36\A 37\A 38\A 39\A 40\A 41\A 42\A 43\A 44\A 45\A 46\A 47\A 48\A 49\A 50\A 51\A 52\A 53\A 54\A 55\A 56\A 57\A 58\A 59\A";
  position: relative;
  white-space: pre;
  display: inline-block;
  animation: unit steps(60) infinite;
  animation-play-state: paused;
}
```

具体可以看[demo地址](https://codepen.io/kevin031-the-scripter/pen/zYGXpPY?editors=1111)

### 难点3 游戏的难度设置

移动端的click事件会有300ms的延迟，首先为了操作的流畅性，引入了``fastclick``这个库，给用户带来实时反馈，但是会有一个副作用，就是理论上来说只要用户点击速度足够快，打破现实中的世界记录是很轻松的事，而手速再快一点的用户，则会看到魔方的旋转十分诡异，在前一步没有结束的情况下便开始了后一步，甚至后两步。

因为魔方的旋转是需要过渡时间的，那么首先要需要让旋转的速度足够快，接着我们只需要对用户的点击事件做节流处理，代码如下

```
function throttle (func, delay) {
  let last, deferTime
  return function (args) {
    let that = this
    let _arg = arguments;

    let now = new Date();
    if (last && now < last + delay) {
      clearTimeout(deferTime)
      deferTime = setTimeout(function () {
        last = now;
        func.apply(that, _args)
      })
    }
  }
}

const handler = throttle(() => {
  // 触发旋转
}, 300)

function handleClick () {
  handler()
}
```

这样一来，最快的时间就会被我控制在一个范围，另外也不是无脑点击屏幕就能最快，因为魔方旋转需要时间，因此在旋转动画快结束的时候按才能让效率达到最高。

以上就是我在这个项目中运用的主要技巧，整个项目做下来用了两三个星期，除了以上提到的难点，剩下大部分的活比较考验CSS的功力和状态管理，这里暂时略过了，以后想到再更。